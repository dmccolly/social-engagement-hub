  // Rich Blog Editor Component
  const RichBlogEditor = ({ onSave, onCancel, editingPost = null }) => {
    const [title, setTitle] = useState(editingPost?.title || '');
    const [content, setContent] = useState(editingPost?.content || '');
    const [isFeatured, setIsFeatured] = useState(editingPost?.isFeatured || false);
    const [isPinned, setIsPinned] = useState(editingPost?.isPinned || false);
    const [selectedImageId, setSelectedImageId] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const [showLinkDialog, setShowLinkDialog] = useState(false);
    const [showYouTubeDialog, setShowYouTubeDialog] = useState(false);
    const [showMediaDialog, setShowMediaDialog] = useState(false);
    const [showToolbar, setShowToolbar] = useState(true); // Always visible now
    const [showVimeoDialog, setShowVimeoDialog] = useState(false);
    const [vimeoUrl, setVimeoUrl] = useState('');
    const [previewSize, setPreviewSize] = useState('mobile');
    const [linkData, setLinkData] = useState({ text: '', url: '' });
    const [youtubeUrl, setYoutubeUrl] = useState('');
    const [mediaData, setMediaData] = useState({ type: 'audio', url: '', title: '' });
    const fileInputRef = useRef(null);
    const mediaInputRef = useRef(null);
    const contentRef = useRef(null);

    // Handle content change - FIXED for backwards typing
    const handleContentChange = (e) => {
      // Remove placeholder when user starts typing
      const placeholderElement = e.target.querySelector('.placeholder-text');
      if (placeholderElement) {
        placeholderElement.remove();
      }
      
      const selection = window.getSelection();
      const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
      const startOffset = range ? range.startOffset : 0;
      const endOffset = range ? range.endOffset : 0;
      const startContainer = range ? range.startContainer : null;
      
      setContent(e.target.innerHTML);
      
      setTimeout(() => {
        if (startContainer && contentRef.current && contentRef.current.contains(startContainer)) {
          try {
            const newRange = document.createRange();
            newRange.setStart(startContainer, Math.min(startOffset, startContainer.textContent?.length || 0));
            newRange.setEnd(startContainer, Math.min(endOffset, startContainer.textContent?.length || 0));
            selection.removeAllRanges();
            selection.addRange(newRange);
          } catch (e) {
            console.log('Cursor restore fallback');
          }
        }
      }, 0);
    };

       // Set initial content only once
       useEffect(() => {
         if (contentRef.current && !contentRef.current.innerHTML) {
           contentRef.current.innerHTML = content || '<p class="placeholder-text" style="color: #9ca3af; font-style: italic;">Start writing your blog post here...</p>';
         }
       }, []);
       
       // Update content only when editing post
       useEffect(() => {
         if (editingPost && contentRef.current) {
           contentRef.current.innerHTML = content || '<p class="placeholder-text" style="color: #9ca3af; font-style: italic;">Start writing your blog post here...</p>';
         }
       }, [editingPost]);


    // Handle file upload with Cloudinary
    const handleFileUpload = async (event) => {
      const files = Array.from(event.target.files);
      if (!files.length) return;

      console.log(`Uploading ${files.length} file(s)`);
      setIsUploading(true);

      // Validate file types and sizes
      const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
      const maxSize = 50 * 1024 * 1024; // 50MB in bytes

      for (const file of files) {
        if (!validTypes.includes(file.type)) {
          alert(`${file.name}: Please upload a valid image file (JPG, PNG, GIF, or WEBP)`);
          setIsUploading(false);
          return;
        }

        if (file.size > maxSize) {
          alert(`${file.name}: File size must be less than 50MB`);
          setIsUploading(false);
          return;
        }
      }

      try {
        // Upload files sequentially
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          console.log(`Uploading file ${i + 1}/${files.length}: ${file.name}`);
          
